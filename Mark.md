# 用于记录一些 git的学习笔记

本文件详细参考了
[git教学视频](https://www.bilibili.com/video/BV1HM411377j?spm_id_from=333.788.videopod.sections&vd_source=9cfe8c96e4fed1941ab35fc34dd2dde3&p=3)的指导，非常简洁高效的掌握基本的git命令和知识，常看常新。

## CP1 git简介

Git 是一个开源的分布式版本控制系统，用于跟踪文件和目录的更改，管理软件开发过程中的代码版本。那么
什么是分布式呢？

* 分布式架构

**本地仓库与远程仓库地位相同**：每个开发者在本地机器上都有一个完整的代码仓库副本，包含了项目的全部历史记录。开发者可以在本地进行开发，然后将更改推送到远程仓库（如 GitHub、GitLab 等），也可以从远程仓库拉取最新的代码。
**支持离线工作**：由于本地仓库的存在，开发者即使在没有网络的情况下也可以继续开发，待网络恢复后再同步到远程仓库。

总结起来，从地位上看，我们的本地仓库和远程的GitHub仓库都只是我们代码的备份仓库之一，所以并不能简单理解GitHub仓库就是云仓库这么简单，后面会提到。

### 1.1 名词解析

* 仓库： 即我们的想要把代码存储起来保存的地方。

## CP2 创建仓库

创建仓库的办法有两种，分别是`git init`和`git clone`

### 2.1 git init

```
git init
```
该命令表示在在当前文件夹目录下新建一个仓库，一般本地仓库常用。如图所示。

![](.\pic\8.png)

我们在`git bash`或者`vscode `终端中 输入改命令即可建立一个本地仓库。

![](.\pic\9.png)

![](.\pic\10.png)

上图，我们可以看见，有个隐藏文件`.git`，即表明这个文件夹下是一个仓库了，受git命令的管理。而且，如果细心观察，我们发现，终端在建立仓库有，有个`(main)`，这是表明当前的**分支**，我们以后再说。

### git clone

字面理解，就是克隆一个仓库到当前位置，这个常用于将`GitHub`上一个远程仓库下载到本地来进行开发，后面会讲到

## CP3 仓库常用操作

### 3.1 仓库的状态

git上管理的文件，一共有三种状态，对应三个区域，分别是**工作区，暂存区 本地仓库**。

* 工作区

我们编辑代码或者文件的地方，可以理解成生产工厂。

* 暂存区

已经被git记录到的文件，但还没有存放到本地仓库的区域，可以理解成从生成工厂成产的产品，装在卡车上准备发往本地仓库存储。

* 本地仓库

顾名思义，就是被git管理起来的文件。


文件在git的管理下有四种状态，分别是**未跟踪untrack 未修改unmodified 已修改Modified 已暂存Staged**四种状态

* Untrack态

一般是git管理文件下的新建的文件，表明这是一个新建的文件，没有纳入git管理的文件。

* Unmodified态

一般是指该文件该文件在纳入git管理过后，没有进行修改的文件的状态

* Modified态

即表示该文件纳入了git管理后，我们又修改了文件中的内容后，git检查到该文件的差异后的状态

* Staged态

存放在本地仓库的文件状态。

已这个`.md`文件为例，我们刚才只是使用
```
git init
```
新建了一个文件，但并未把这个`.md`文件纳入管理，因此，使用他应该是`Untrack`状态，处于工作区中。

### git status

用于获取当前仓库和工作区和暂存区的文件状态。直接使用
```
git status 
```

![](.\pic\11.png)

可以看见，我们新建这个的`.md`文件是`Untrack`态。

### git add

用于将工作区中的`Untrack`态文件转移到暂存区中.命令格式如下
```
git add 文件相对路径
```

```
git add . 
```
表示将所有未跟踪文件加入暂存区。

![](.\pic\12.png)

### git commit

用于将暂存区的文件加入到本地仓库中供git管理。

```
git commit -m "对该版本说明的内容"
```

也可以这样写
```
git commit -am "对该版本说明的内容"
```
表示直接 add 后 commit。

也可以
```
git commit
```
执行后，会弹出一个文本编辑器，要求你添加对该版本提交文件的说明，相当于签字确认

![](.\pic\13.png)

最后，给出我在视频中截的图，非常直观的表示了各个命令对文件状态的改变。

![](.\pic\1.png)

![](.\pic\2.png)

### 一些命令的总结

![](.\pic\14.png)

### git ls-files

这个命令用于查看在暂存区中记录的文件名称。

```
git ls-files
```

如图所示

![](.\pic\18.png)

加入我们增加了些图片或者文件，后我们在查看

![](.\pic\19.png)

### git log

这个命令用于查看目前git 的版本记录历史

```
git log
```
如下图所示

![](.\pic\15.png)

commit 字段后面跟着的一堆数组和字母就是那个版本的版本ID，我们可以使用命令配合这个ID使版本退回到我们想要的任意版本号中。

`git log`还可以这样简洁显示信息

```
git log --oneline
```

效果如图

![](.\pic\16.png)

细心者会发现，有个`(HEAD->main)`这个字段，这表示目前的分支是`main`，且头指针`Head`指向这一行的`1.3 version 2025/3/4`版本

### git reset

言归正传，我们可以使用这个命令来使得版本前进或者后退到任意我们的提交过的版本，即使得`HEAD`指向当前指针的任意版本。

`git reset`命令可以跟三个参数，分别是
```
git reset --soft
git reset --hard
git rest  --mixed
```

它们的区别如下图所示

![](.\pic\17.png)

为了方便演示，我们格外开一仓库并先创建3个文件，并将它们分别进行三次提交。如下图所示


* --soft 
![](.\pic\23.png)

![](.\pic\24.png)


我们回退到前一个版本，看看效果。

```
git reset --soft HEAD^
```

效果如图所示

![](.\pic\25.png)

![](.\pic\26.png)

我们发现，git显示状态是file3未添加，且工作区还有file3文件的状态，看看暂存区有无file3

`git ls-files`查看暂存区情况

![](.\pic\27.png)

我们发现暂存区里面保留了对file3的记录。

`git reset`不仅可以后退，还可以前进，比如我们恢复到加入了file3的最新版本

```
git reset --soft file3的版本号
```

* --hard

假设我们还在file3的最新版本，我们使用
```
git reset --hard HEAD^
```
效果如图所示，

git状态\
![](.\pic\28.png)

工作区状态\
![](.\pic\29.png)

暂存区状态
![](.\pic\30.png)

所以，值得注意的是，`hard`参数在日常的使用中一定要慎用，因为它会重置的比较彻底。

* mixed

这个配合之前的命令自行探索，效果已经在之前给出了

### git reflog

承接上一个指令的内容，假如我们不小心`git reset --hard`，我们如何回退到之前有file3的版本呢？

我们打开`git log --oneline`发现，此时没有我们之前file3版本提交的id号了，

![](.\pic\31.png)

那不是丸辣？ 别急，有的 兄弟 有的，我们只需要使用回滚命令就可以查看到历史提交版本了。

```
git reflog
```

![](.\pic\32.png)

然后，我们再配合`reset`命令即可

文件即可恢复

### git diff

这个命令用于显示受git管理的一个文件在两个版本之间的差异。这个命令简单介绍，因为我们有vscode等可视化工具来显示文件的差异

假设我们提交了一个file1.txt，现在我们仅在工作区来修改它。

![](.\pic\33.png)

使用
```
git diff file1.txt
```

效果如图

![](.\pic\34.png)

绿色的一行内容就是表示差异， `+`表明工作区新增了一行这个内容，而git版本库中没有。这也表明了**git diff默认是比较工作区和仓库之间的差异**

也可以 加上`--cached`来比较暂存区和版本库之间文件的差异
```
git diff --cached file1.txt
```

![](.\pic\35.png)

表明暂存区的内容和版本库中的是一致的。

`git diff`除了比较上诉三个区域内文件的差异，也可以比较两个特征版本之间文件的差异，如下

```
git diff 版本ID1 版本ID2 文件
```
效果如图\
![](.\pic\36.png)


### git rm

从版本库中删除文件。

一般受git管理的仓库，我们不使用`rm 文件`来删除文件，因为`rm`只表示将工作区的文件删除，因此，这样删除文件后需要`git add `和`git commit`来更新暂存区和版本库中删除

因此，使用`git rm`可以一个命令代替上面所有指令。

```
git rm 文件
```

效果如图所示\
![](.\pic\37.png)
![](.\pic\38.png)

总结

![](.\pic\39.png)

### .gitignore

用于git管理一些需要git忽略的文件。

![](.\pic\40.png)

我们创建一个file3.txt和password.txt的文件，我们将file3.txt纳入git管理，而不想password.txt纳入git管理中

```
echo password.txt > .gitignore
```

即创建一个`.gitignore`的文件来记录需要被git忽略管理的文件名称。

这样过后，我们对比git对password.txt的管理

![](.\pic\41.png)
![](.\pic\42.png)

我们提交一下，看看暂存区的效果

![](.\pic\43.png)

发现，暂存区也没有相关记录，说明`password.txt`这个文件已经被git忽略管理。即使我们修改了其中的内容，也不会被git跟踪。

值得注意的是`.gitignore`适配shell语言，即它支持通配符语法，打开`.gitignore`
```
password.txt
*.txt
```
这表示它以后将忽略所有.txt后缀的文件管理

**注意，想要git忽略管理某个文件，需要这个文件事先不被git所管理，而是一开始就添加到.gitignore**文件，否则git仍会管理这个文件，即使它后续假如到到了`.gitignor`中了。

**如果文件夹是空的，则假如.gitignore后不会生效**

这里补充下`gitignore`的匹配规则和示意

![](.\pic\44.png)

![](.\pic\45.png)

## CP4 GitHub篇

我们这章将会新建一个GitHub的远程仓库，并学习它如何通过git和本地仓库相互联系。

### 创建一个GitHub仓库

我们假设你已经学会了如何注册GitHub账号，并配置好了SSH等配置。如有不懂，请看[github注册教程](https://www.bilibili.com/video/BV1HM411377j?spm_id_from=333.788.videopod.sections&vd_source=9cfe8c96e4fed1941ab35fc34dd2dde3&p=11)

### 管理本地和远程仓库

如图，我们点击我们的`repo`界面

![](.\pic\46.png)

我们点击右上角的绿色`new`按键来创建一个远程仓库

![](.\pic\47.png)

之后，我们要创建一个空仓库

![](.\pic\48.png)

我们的空仓库创建完毕，如下图所示

![](.\pic\49.png)

它就相当于我们电脑上的一个空文件夹，受git管理，目前它和我们本地的仓库仍然是独立的关系，接下来，我们要关联它们两者

### 将本地仓库上传至远程仓库

我们先从本地仓库上传到这个远程仓库中。我们首先需要找到这个远程仓库的网址，我们在上一张图片中已经标注了这个远程仓库的网址，接下来需要在本地仓库中管理住它

### git remote

这个指令表示本地仓库关联一个远程的仓库。

```
git remote add origin git@github.com:Mikelunch/gitTutor.git
```

这里的`origin`即本地仓库认为的远程仓库的名称，可以是其他名字。


除此之外，
```
git remote -v
```
可以来参看本地仓库关联的远程仓库

![](.\pic\50.png)

接下来我们可以创建一个分支,由于我们本地已经创建了一个`main`分支，所以我们不会接下来的这个命令可以忽略

```
git branch -m main
```

`git branch`十分重要，之后我们会介绍她

### git push

最后，我们需要将本地仓库上传到远程仓库。

```
git push -u origin main:main
```

-u即表示将本地仓库和远程仓库关联起来， 接下里的origin即我们本地仓库认为的远程仓库的名称`origin`，`main:main`表示将本地的main分支长传到远程的main分支上

![](.\pic\51.png)

![](.\pic\52.png)

这样，就成功将这个本地仓库和远程仓库关联起来了。

### git pull

这个命令用来将远程仓库中的修改同步到本地仓库中。我们在giuhub上去这个文件下去编辑一下

![](.\pic\53.png)

![](.\pic\54.png)

```
这行代码是在github上编辑的
```
我们对比github版本上的和本地仓库，会发现，本地仓库没有这段代码，因此，我们需要同步这个改变到本地仓库中去。在本地的`git`中
```
git pull origin main
```
它表示从远程仓库`origin`中拉去`main`分支同步到本地。同步过后的效果如下

![](.\pic\55.png)

总结一下

![](.\pic\56.png)

### git clone

假如我们本地没有仓库，而github上有仓库，我们也可以从github上下载一个仓库到本地，操作和上一节的内容是完全镜像的。

我们新建一个空文件夹，并将它纳入git管理。

![](.\pic\57.png)

我们就利用上一节的github上传来克隆它到这个文件夹下。

![](.\pic\58.png)

```
git remote add origin git@github.com:Mikelunch/gitTutor.git
```

然后使用
```
git clone git@github.com:Mikelunch/gitTutor.git
```

即可下载，美美得吃

![](.\pic\59.png)


## CP5 分支

分支是一种多人开发十分重要的流程，项目的`main`分支就是主干，每次的提交就是树中主干的一个节点，我们可以从每个节点都衍生出一个分支，用来处理其他的东西，而不影响主干的代码，最后在进行合并，将分支合并进主干中，从而完善主干。这就是分支基本的作用

![](.\pic\60.png)


假设我们按下图的方式，先建立好`main`分支

![](.\pic\61.png)

为了方便展示，我们在`vscode`上能很好的参看当前分支的情况

![](.\pic\62.png)

### git branch

接下来，我们创建新的分支`dev`

```
git branch dev
```

即可，接下来，使用
```
git branch -v
```

可以查看本地仓库中的所有分支，如图所示

![](.\pic\63.png)

### git switch

用于切换分支

```
git switch dev
```

可以看见，后面的分支名称变成了dev

![](.\pic\64.png)

然后，我们在对dev进行一些文件的添加，如上面的分支图提到的那样提交后。我们切换回`main`分支，利用`ls`命令参看`main`分支下git的管理文件目录，如图所示

![](.\pic\65.png)

然后我们在切换回去`dev`分支，同样`ls`看看，如图所示

![](.\pic\67.png)

甚至连本文件都恢复到了`main:3`分支时候的记录，非常牛皮

![](.\pic\66.png)

而且，在`main`分支下，`dev`分支创建的文件`dev1`等是不可见的
![](.\pic\68.png)

说明主干分支`main`和`dev`分支分离后的文件状态彼此是独立的，且文件的状态仅在它自己的分支下可见。

### git merge

承接上文，假设我们已经对`dev`分支版本的代码进行了开发，现在是时候让他重回`main`分支了，整合成新的分支了

**注意，在main分支下，使用下面的代码**

```
git merge dev
```

我们就可以在`main`分支下看到`dev`分支开发的内容，帮整合到了`main`分支下。

![](.\pic\69.png)

这里，vscode也可视化的为我们展示了合并的分支过程

![](.\pic\70.png)


**注意**，合并过后的分支仍然存在，并且仍然独立于`main`分支，这意味着我们在`dev`分支上继续开发，只要不合并，在`main`分支上也是不可见的

![](.\pic\71.png)


因此，当一个分支不被需要的时候，我们需要手动删除它

```
git branch -d dev
```

此时如果提醒我们失败，可能是分支中还有节点没有如何到`main`分支下

![](.\pic\72.png)

可以
```
git branch -D dev
```

强制删除，也可融合后再删除，up to you

![](.\pic\73.png)

* 总结

![](.\pic\74.png)
